'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _superagent = require('superagent');

var _superagent2 = _interopRequireDefault(_superagent);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _config = require('../config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TIMEOUT = 15000;

function makeUrl(url) {
  var newUrl = url;
  if (_lodash2.default.isArray(newUrl)) {
    newUrl = '/' + newUrl.join('/');
  }
  if (__CLIENT__) {
    newUrl = '/api' + newUrl;
  } else {
    newUrl = 'http://' + _config2.default.apiHost + ':' + _config2.default.apiPort + newUrl;
  }
  return newUrl;
}

function removeValue(arr, value) {
  _lodash2.default.remove(arr, function (item) {
    return item === value;
  });
}

var _pendingRequests = [];

// Abor the requests for the Api Call with the specified name.
// Be careful since won't make any difference if the same api call gets
// called with diffrent query strings or body, this feature stops any
// pending call for the specified Api Call
function abortPendingRequestsForApiCall(apiCallName) {
  var pendingRequest = _lodash2.default.find(_pendingRequests, function (pending) {
    return pending._apiCallName === apiCallName;
  });

  if (pendingRequest) {
    pendingRequest._callback = function () {};
    pendingRequest.abort();
    removeValue(_pendingRequests, pendingRequest);
  }
}

function _isSuccessStatus(status) {
  return status >= 200 && status <= 299;
}

function defaultParser(res) {
  var result = null;
  if (_isSuccessStatus(res.status)) {
    result = this.done(res.body);
  } else {
    result = this.fail(res.body);
  }
  return result;
}

function digestResponse(resolve, reject, error, request, response, options) {
  var result = {};

  // Autofail with standard api error on timeout.
  if (error && error.timeout >= 0) {
    result.apiError = 'TIMEOUT';
    reject(result);

    // Auto-fail with special auth error on 401.
  } else if (response && response.status === 401) {
    result.apiResponse = response.body || {};
    result.apiError = 'AUTH_ERROR';
    reject(result);

    // Auto-fail with special api down error on 502 - 504.
    // IE can do weird things with 5xx errors like call them 12031s.
  } else if (response && response.status >= 502 && response.status <= 504 || response.status > 12000) {
    result.apiResponse = response.body || {};
    result.apiError = '500_ERROR';
    reject(result);
  } else if (response && response.status === 429) {
    result.apiResponse = response.body || {};
    result.apiError = 'RATE_LIMIT_ERROR';
    reject(result);

    // Autofail with standard api error.
  } else if (error) {
    result.apiResponse = response.body || {};
    result.apiError = 'ERROR';
    reject(result);
  } else {
    response.body = response.body || {}; // patch response.body if nonexistant
    var gotExpectedResponse = void 0;
    var parser = options.parse || defaultParser;

    var done = function done(data) {
      gotExpectedResponse = true;
      result.apiResponse = data || {};
      resolve(result);
    };

    var fail = function fail(err) {
      gotExpectedResponse = true;
      result.apiResponse = err || {};
      result.apiError = err;
      reject(result);
    };

    var pass = function pass() {
      // do nothing.  don't resolve or reject the promise.
      gotExpectedResponse = true;
    };

    parser.call({ done: done, fail: fail, pass: pass }, response);

    // Our parser did not get a response it understands
    if (!gotExpectedResponse) {
      result.apiError = 'UNKOWN ERROR';
      reject(result);
    }
  }
}

function executeRequestFlow(options, origReq) {
  return new Promise(function requestPromise(resolve, reject) {
    options.method = options.method || 'GET';
    var url = options.absolutePath || makeUrl(options.path);
    var request = (0, _superagent2.default)(options.method, url);
    var query = {};
    if (['GET', 'POST', 'PUT'].indexOf(options.method) > -1) {
      request.accept('json');
      request.type('json');
    }

    if (['POST', 'PUT'].indexOf(options.method) > -1) {
      options.body = options.body || {};
    }

    // If you need to set a cookie do as follow:
    // request.set('Cookie', sessionCookie);

    if (options.body) {
      request.send(options.body);
      Object.keys(options.body).forEach(function processKey(key) {
        if (options.body[key] === undefined) {
          console.warn('Key was undefined in request body:', key);
        }
      });
    }

    if (options.headers && _lodash2.default.isPlainObject(options.headers)) {
      request.set(options.headers);
    }

    if (options.query) {
      _lodash2.default.extend(query, options.query);
    }

    if (Object.keys(query).length) {
      request.query(query);
    }

    request.timeout(TIMEOUT);

    // Prevent concurrent calls for the same Api Call type.
    if (options.cancelPendingRequests) {
      if (request.dashapiCallName) console.log('WARNING: Prop clashing with request object');
      if (!options.apiCallName) console.log('WARNING: To cancel previous calls the Api Call needs a name defined.');

      request._apiCallName = options.apiCallName;

      abortPendingRequestsForApiCall(options.apiCallName);
    }

    // Request Callback logic
    request.end(function (error) {
      var response = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      digestResponse(resolve, reject, error, request, response, options);
      removeValue(_pendingRequests, request);
    });

    _pendingRequests.push(request);
  });
}

// API Interface

var Api = function () {
  function Api(origReq) {
    _classCallCheck(this, Api);

    this.origReq = origReq;
  }

  _createClass(Api, [{
    key: 'get',
    value: function get(options) {
      options.method = 'GET';
      return executeRequestFlow(options, this.origReq);
    }
  }, {
    key: 'put',
    value: function put(options) {
      options.method = 'PUT';
      return executeRequestFlow(options, this.origReq);
    }
  }, {
    key: 'post',
    value: function post(options) {
      options.method = 'POST';
      return executeRequestFlow(options, this.origReq);
    }
  }, {
    key: 'delete',
    value: function _delete(options) {
      options.method = 'DELETE';
      return executeRequestFlow(options, this.origReq);
    }
  }, {
    key: 'head',
    value: function head(options) {
      options.method = 'HEAD';
      return executeRequestFlow(options, this.origReq);
    }
  }, {
    key: 'isSuccessStatus',
    value: function isSuccessStatus(status) {
      return _isSuccessStatus(status);
    }
  }]);

  return Api;
}();

exports.default = Api;
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(TIMEOUT, 'TIMEOUT', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/api/api.js');

  __REACT_HOT_LOADER__.register(makeUrl, 'makeUrl', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/api/api.js');

  __REACT_HOT_LOADER__.register(removeValue, 'removeValue', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/api/api.js');

  __REACT_HOT_LOADER__.register(_pendingRequests, '_pendingRequests', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/api/api.js');

  __REACT_HOT_LOADER__.register(abortPendingRequestsForApiCall, 'abortPendingRequestsForApiCall', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/api/api.js');

  __REACT_HOT_LOADER__.register(_isSuccessStatus, 'isSuccessStatus', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/api/api.js');

  __REACT_HOT_LOADER__.register(defaultParser, 'defaultParser', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/api/api.js');

  __REACT_HOT_LOADER__.register(digestResponse, 'digestResponse', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/api/api.js');

  __REACT_HOT_LOADER__.register(executeRequestFlow, 'executeRequestFlow', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/api/api.js');

  __REACT_HOT_LOADER__.register(Api, 'Api', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/api/api.js');
}();

;