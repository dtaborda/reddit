'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.set = set;
exports.merge = merge;
exports.without = without;
exports.immutable = immutable;

var _seamlessImmutable = require('seamless-immutable');

var _seamlessImmutable2 = _interopRequireDefault(_seamlessImmutable);

var _lodash = require('lodash');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
* Collection of helpers to perform operations on objects/arrays.
* The current implementation works under the assumption of seamless-immutable
* collections wrapping all our objects/arrays.
* The beauty of this is that we can easily migrate this impl to use other library
* or just use plain objects if we want and all the reducers should work as usual.
*/

/*
* Returns a new object also containing the new key, value pair.
* If an equivalent key already exists in this Map, it will be replaced.
* You can use as a shortcut nexted paths (delimited by dots).
*/
function set(sourceObject, keyPath, value) {
  if ((0, _lodash.isPlainObject)(keyPath)) {
    return sourceObject.merge(keyPath);
  }

  var keys = (0, _lodash.isArray)(keyPath) ? keyPath : keyPath.split('.');

  //TODO: This will only short circuit at the very first execution,
  // when doing recursion, we don't need this anymore and is time spent.
  // seamless-immutable is handling this in SOME of the cases, but not others
  // (remove this line and run test to see it fails). How we can improve this?
  if (getIn(sourceObject, keys) === value) return sourceObject;

  var merged = {};
  if (keys.length === 1) {
    if ((0, _lodash.isPlainObject)(sourceObject)) {
      merged[keys[0]] = value;
      return sourceObject.merge(merged);
    } else if ((0, _lodash.isArray)(sourceObject)) {
      var newObject = sourceObject.asMutable();
      newObject[keys[0]] = value;
      return (0, _seamlessImmutable2.default)(newObject);
    } else if ((0, _lodash.isUndefined)(sourceObject)) {
      var _newObject = {};
      _newObject[keys[0]] = value;
      return (0, _seamlessImmutable2.default)(_newObject);
    }
  } else {
    if ((0, _lodash.isPlainObject)(sourceObject)) {
      merged[keys[0]] = set(sourceObject[keys[0]], keys.slice(1), value);
      return sourceObject.merge(merged);
    } else if ((0, _lodash.isArray)(sourceObject)) {
      var _newObject2 = sourceObject.asMutable();
      _newObject2[keys[0]] = set(sourceObject[keys[0]], keys.slice(1), value);
      return (0, _seamlessImmutable2.default)(_newObject2);
    } else if ((0, _lodash.isUndefined)(sourceObject)) {
      merged[keys[0]] = set(undefined, keys.slice(1), value);
      return (0, _seamlessImmutable2.default)(merged);
    }
  }
}

/*
* Returns a new object resulting from merging the source object the new one.
* The keyPath allows you to specify at which level to perform the merge, or if you
* send the object to merge instead of a keyPath then it will be used to be merged
* on the root level of the source object. This will perform a deep merge but won't
* affect those siblings or keys that already existed in the source object, will
* only override existing keys with the values from the new object.
*
*/
function merge(sourceObject, keyPath, object) {
  var deep = { deep: true };
  if ((0, _lodash.isObject)(keyPath)) {
    return sourceObject.merge(keyPath, deep);
  } else {
    return sourceObject.merge(buildNestedObject({}, keyPath, object), deep);
  }
}

/*
* Returns a new object containing all the keys / values from the source object
* but the one specified in the `key` parameter.
*/
function without(sourceObject, key) {
  return sourceObject.without(key);
}

/*
* Wrap the object as a seamless immutable object.
*/
function immutable(object) {
  return (0, _seamlessImmutable2.default)(object);
}

/***
* Utilitary functions
*/

/*
* Private: Take a key patch such as "student.teacher.name" and a value to build
* the nested structure with that value assigned. Also expects an initial object
* to use for building the structure.
* f.i:
*   buildNestedObject({}, "student.teacher.name", "john") => {student: {teacher: {name: "john"}}}
*/
function buildNestedObject() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var keyPath = arguments[1];
  var value = arguments[2];

  var keys = (0, _lodash.isArray)(keyPath) ? keyPath : keyPath.split('.');

  if (keys.length === 1) {
    obj[keys[0]] = value;
  } else {
    var key = keys.shift();
    obj[key] = buildNestedObject(typeof obj[key] === 'undefined' ? {} : obj[key], keys, value);
  }

  return obj;
}

/*
* Private: Return the value at the given key path.
* keyPath can be either an array of keys or a string delimited by dots.
* Useful for getting values in a nested object.
* f.i: getIn(object, "key1.key2.name")
*/
function getIn(object, keyPath) {
  var keys = (0, _lodash.isArray)(keyPath) ? keyPath : keyPath.split('.');

  if ((0, _lodash.isUndefined)(object)) {
    return undefined;
  }

  if (keys.length === 1) {
    return object[keys[0]];
  } else {
    return getIn(object[keys[0]], keys.slice(1));
  }
}
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(set, 'set', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/reducers/utils/immutable_helpers.js');

  __REACT_HOT_LOADER__.register(merge, 'merge', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/reducers/utils/immutable_helpers.js');

  __REACT_HOT_LOADER__.register(without, 'without', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/reducers/utils/immutable_helpers.js');

  __REACT_HOT_LOADER__.register(immutable, 'immutable', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/reducers/utils/immutable_helpers.js');

  __REACT_HOT_LOADER__.register(buildNestedObject, 'buildNestedObject', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/reducers/utils/immutable_helpers.js');

  __REACT_HOT_LOADER__.register(getIn, 'getIn', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/reducers/utils/immutable_helpers.js');
}();

;