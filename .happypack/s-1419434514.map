{"version":3,"sources":["app/reducers/utils/immutable_helpers.js"],"names":["set","merge","without","immutable","sourceObject","keyPath","value","keys","split","getIn","merged","length","newObject","asMutable","slice","undefined","object","deep","buildNestedObject","key","obj","shift"],"mappings":"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","file":"immutable_helpers.js","sourceRoot":"/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge","sourcesContent":["import immutableLib from 'seamless-immutable';\nimport {\n  isPlainObject,\n  isArray,\n  isUndefined,\n  isObject\n} from 'lodash';\n\n/**\n* Collection of helpers to perform operations on objects/arrays.\n* The current implementation works under the assumption of seamless-immutable\n* collections wrapping all our objects/arrays.\n* The beauty of this is that we can easily migrate this impl to use other library\n* or just use plain objects if we want and all the reducers should work as usual.\n*/\n\n/*\n* Returns a new object also containing the new key, value pair.\n* If an equivalent key already exists in this Map, it will be replaced.\n* You can use as a shortcut nexted paths (delimited by dots).\n*/\nexport function set(sourceObject, keyPath, value) {\n  if (isPlainObject(keyPath)) {\n    return sourceObject.merge(keyPath);\n  }\n\n  const keys = isArray(keyPath) ? keyPath : keyPath.split('.');\n\n  //TODO: This will only short circuit at the very first execution,\n  // when doing recursion, we don't need this anymore and is time spent.\n  // seamless-immutable is handling this in SOME of the cases, but not others\n  // (remove this line and run test to see it fails). How we can improve this?\n  if (getIn(sourceObject, keys) === value) return sourceObject;\n\n\n  const merged = {};\n  if (keys.length === 1) {\n    if (isPlainObject(sourceObject)) {\n      merged[keys[0]] = value;\n      return sourceObject.merge(merged);\n    } else if (isArray(sourceObject)) {\n      const newObject = sourceObject.asMutable();\n      newObject[keys[0]] = value;\n      return immutableLib(newObject);\n    } else if (isUndefined(sourceObject)) {\n      const newObject = {};\n      newObject[keys[0]] = value;\n      return immutableLib(newObject);\n    }\n  } else {\n    if (isPlainObject(sourceObject)) {\n      merged[keys[0]] = set(sourceObject[keys[0]], keys.slice(1), value);\n      return sourceObject.merge(merged);\n    } else if (isArray(sourceObject)) {\n      const newObject = sourceObject.asMutable();\n      newObject[keys[0]] = set(sourceObject[keys[0]], keys.slice(1), value);\n      return immutableLib(newObject);\n    } else if (isUndefined(sourceObject)) {\n      merged[keys[0]] = set(undefined, keys.slice(1), value);\n      return immutableLib(merged);\n    }\n  }\n}\n\n\n\n/*\n* Returns a new object resulting from merging the source object the new one.\n* The keyPath allows you to specify at which level to perform the merge, or if you\n* send the object to merge instead of a keyPath then it will be used to be merged\n* on the root level of the source object. This will perform a deep merge but won't\n* affect those siblings or keys that already existed in the source object, will\n* only override existing keys with the values from the new object.\n*\n*/\nexport function merge(sourceObject, keyPath, object) {\n  const deep = { deep: true };\n  if (isObject(keyPath)) {\n    return sourceObject.merge(keyPath, deep);\n  } else {\n    return sourceObject.merge(buildNestedObject({}, keyPath, object), deep);\n  }\n}\n\n/*\n* Returns a new object containing all the keys / values from the source object\n* but the one specified in the `key` parameter.\n*/\nexport function without(sourceObject, key) {\n  return sourceObject.without(key);\n}\n\n/*\n* Wrap the object as a seamless immutable object.\n*/\nexport function immutable(object) {\n  return immutableLib(object);\n}\n\n\n\n\n/***\n* Utilitary functions\n*/\n\n/*\n* Private: Take a key patch such as \"student.teacher.name\" and a value to build\n* the nested structure with that value assigned. Also expects an initial object\n* to use for building the structure.\n* f.i:\n*   buildNestedObject({}, \"student.teacher.name\", \"john\") => {student: {teacher: {name: \"john\"}}}\n*/\nfunction buildNestedObject(obj = {}, keyPath, value) {\n  const keys = isArray(keyPath) ? keyPath : keyPath.split('.');\n\n  if (keys.length === 1) {\n    obj[keys[0]] = value;\n  } else {\n    const key = keys.shift();\n    obj[key] = buildNestedObject(typeof obj[key] === 'undefined' ? {} : obj[key], keys, value);\n  }\n\n  return obj;\n}\n\n\n\n/*\n* Private: Return the value at the given key path.\n* keyPath can be either an array of keys or a string delimited by dots.\n* Useful for getting values in a nested object.\n* f.i: getIn(object, \"key1.key2.name\")\n*/\nfunction getIn(object, keyPath) {\n  const keys = isArray(keyPath) ? keyPath : keyPath.split('.');\n\n  if (isUndefined(object)) { return undefined; }\n\n  if (keys.length === 1) {\n    return object[keys[0]];\n  } else {\n    return getIn(object[keys[0]], keys.slice(1));\n  }\n}\n"]}