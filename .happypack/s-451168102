'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createAPIMiddleware;

var _custom_promise = require('utils/custom_promise');

var _lodash = require('lodash');

/*
* Middleware to accept actions like:
* To accept async actions.
* An async action is an action that has a type with the shape:
* type: {request: requestType, done: doneType, fail: failType}
* If the action type is provided has the shape shown above it will be
* treated as an async action and dispatch the request version and then
* execute the api call provided on the action.
*
* If the action type is a string then is treated as a sync action.
*/
function createAPIMiddleware(apiClient) {
  return function (_ref) {
    var dispatch = _ref.dispatch;
    var getState = _ref.getState;

    return function (next) {
      return function (action) {
        var type = action.type;
        var callAPI = action.callAPI;
        var _action$shouldCallAPI = action.shouldCallAPI;
        var shouldCallAPI = _action$shouldCallAPI === undefined ? function () {
          return true;
        } : _action$shouldCallAPI;
        var _action$payload = action.payload;
        var payload = _action$payload === undefined ? {} : _action$payload;


        if (!type) {
          throw new Error('Not type provided for the action');
        }

        // Validate the type provided
        if ((0, _lodash.isString)(type) || type.rootCode) {
          if (callAPI) {
            throw new Error('The action: [' + type + '] was dispatched as a sync action but provided an Api Call, which is not coherent');
          }
          // This is a sync action, just dispatch and return.
          return next(action);
        }

        if ((0, _lodash.isObject)(type)) {
          if (!(0, _lodash.isObject)(type.request)) throw new Error('Action type.request is expected to be a Object. The value provided was: [' + type.request + ']');
          if (!(0, _lodash.isObject)(type.done)) throw new Error('Action type.request is expected to be a Object. The value provided was: [' + type.done + ']');
          if (!(0, _lodash.isObject)(type.fail)) throw new Error('Action type.request is expected to be a Object. The value provided was: [' + type.fail + ']');
        } else {
          throw new Error('Action type was expected to be an Object.');
        }

        // We are in presence of a async action, therefore validate it has a
        // api call.
        if (typeof callAPI !== 'function') {
          throw new Error('Expected fetch to be a function.');
        }

        if (!shouldCallAPI(getState())) {
          return;
        }

        dispatch({ payload: payload, type: type.request });

        // Always return a 'resolved' promise. This means that we don't need
        // to use .catch or .then(null, errorHandler) when consuming the result
        // of the dispatch. This also means that now everytime you attach to
        // .then when calling .dispatch() you need to check if the result was
        // an expected negative flow or a positive flow, you can eaily do that
        // by checking on the params .then((result) => result.error) f.i.
        return callAPI(apiClient).then(function (result) {
          return _custom_promise.CustomPromise.resolve(dispatch({ payload: payload, apiResponse: result.apiResponse, type: type.done }));
        }, function (result) {
          return _custom_promise.CustomPromise.resolve(dispatch({ payload: payload, apiResponse: result.apiResponse, apiError: result.apiError, type: type.fail }));
        });
      };
    };
  };
}
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(createAPIMiddleware, 'createAPIMiddleware', '/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge/app/middleware/async_actions_middleware.js');
}();

;