{"version":3,"sources":["app/middleware/async_actions_middleware.js"],"names":["createAPIMiddleware","apiClient","dispatch","getState","next","action","type","callAPI","shouldCallAPI","payload","Error","rootCode","request","done","fail","then","result","resolve","apiResponse","apiError"],"mappings":";;;;;kBAcwBA,mB;;AAdxB;;AACA;;AAEA;;;;;;;;;;;AAWe,SAASA,mBAAT,CAA6BC,SAA7B,EAAwC;AACrD,SAAO,gBAA4B;AAAA,QAAzBC,QAAyB,QAAzBA,QAAyB;AAAA,QAAfC,QAAe,QAAfA,QAAe;;AACjC,WAAO,UAAUC,IAAV,EAAgB;AACrB,aAAO,UAAUC,MAAV,EAAkB;AAAA,YAErBC,IAFqB,GASnBD,MATmB,CAErBC,IAFqB;AAAA,YAGrBC,OAHqB,GASnBF,MATmB,CAGrBE,OAHqB;AAAA,oCASnBF,MATmB,CAIrBG,aAJqB;AAAA,YAIrBA,aAJqB,yCAIL;AAAA,iBAAM,IAAN;AAAA,SAJK;AAAA,8BASnBH,MATmB,CAQrBI,OARqB;AAAA,YAQrBA,OARqB,mCAQX,EARW;;;AAWvB,YAAI,CAACH,IAAL,EAAW;AACT,gBAAM,IAAII,KAAJ,CAAU,kCAAV,CAAN;AACD;;AAED;AACA,YAAI,sBAASJ,IAAT,KAAkBA,KAAKK,QAA3B,EAAqC;AACnC,cAAIJ,OAAJ,EAAa;AACX,kBAAM,IAAIG,KAAJ,mBAA0BJ,IAA1B,uFAAN;AACD;AACD;AACA,iBAAOF,KAAKC,MAAL,CAAP;AACD;;AAED,YAAI,sBAASC,IAAT,CAAJ,EAAoB;AAClB,cAAI,CAAC,sBAASA,KAAKM,OAAd,CAAL,EAA6B,MAAM,IAAIF,KAAJ,+EAAsFJ,KAAKM,OAA3F,OAAN;AAC7B,cAAI,CAAC,sBAASN,KAAKO,IAAd,CAAL,EAA0B,MAAM,IAAIH,KAAJ,+EAAsFJ,KAAKO,IAA3F,OAAN;AAC1B,cAAI,CAAC,sBAASP,KAAKQ,IAAd,CAAL,EAA0B,MAAM,IAAIJ,KAAJ,+EAAsFJ,KAAKQ,IAA3F,OAAN;AAC3B,SAJD,MAIO;AACL,gBAAM,IAAIJ,KAAJ,CAAU,2CAAV,CAAN;AACD;;AAED;AACA;AACA,YAAI,OAAOH,OAAP,KAAmB,UAAvB,EAAmC;AACjC,gBAAM,IAAIG,KAAJ,CAAU,kCAAV,CAAN;AACD;;AAED,YAAI,CAACF,cAAcL,UAAd,CAAL,EAAgC;AAC9B;AACD;;AAEDD,iBAAS,EAAEO,SAASA,OAAX,EAAoBH,MAAMA,KAAKM,OAA/B,EAAT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAOL,QAAQN,SAAR,EAAmBc,IAAnB,CACL,UAACC,MAAD;AAAA,iBAAY,8BAAcC,OAAd,CAAsBf,SAAS,EAAEO,SAASA,OAAX,EAAoBS,aAAaF,OAAOE,WAAxC,EAAqDZ,MAAMA,KAAKO,IAAhE,EAAT,CAAtB,CAAZ;AAAA,SADK,EAEL,UAACG,MAAD;AAAA,iBAAY,8BAAcC,OAAd,CAAsBf,SAAS,EAAEO,SAASA,OAAX,EAAoBS,aAAaF,OAAOE,WAAxC,EAAqDC,UAAUH,OAAOG,QAAtE,EAAgFb,MAAMA,KAAKQ,IAA3F,EAAT,CAAtB,CAAZ;AAAA,SAFK,CAAP;AAID,OAtDD;AAuDD,KAxDD;AAyDD,GA1DD;AA2DD;;;;;;;;gCA5DuBd,mB","file":"async_actions_middleware.js","sourceRoot":"/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge","sourcesContent":["import { CustomPromise } from 'utils/custom_promise';\nimport { isString, isObject } from 'lodash';\n\n/*\n* Middleware to accept actions like:\n* To accept async actions.\n* An async action is an action that has a type with the shape:\n* type: {request: requestType, done: doneType, fail: failType}\n* If the action type is provided has the shape shown above it will be\n* treated as an async action and dispatch the request version and then\n* execute the api call provided on the action.\n*\n* If the action type is a string then is treated as a sync action.\n*/\nexport default function createAPIMiddleware(apiClient) {\n  return ({ dispatch, getState }) => {\n    return function (next) {\n      return function (action) {\n        const {\n          type,\n          callAPI,\n          shouldCallAPI = () => true,\n          // Default to an empty object but let user provide\n          // here the parameters used during dispatch in case they are required\n          // by the DONE or FAIL action.\n          payload = {}\n        } = action;\n\n        if (!type) {\n          throw new Error('Not type provided for the action');\n        }\n\n        // Validate the type provided\n        if (isString(type) || type.rootCode) {\n          if (callAPI) {\n            throw new Error(`The action: [${type}] was dispatched as a sync action but provided an Api Call, which is not coherent`);\n          }\n          // This is a sync action, just dispatch and return.\n          return next(action);\n        }\n\n        if (isObject(type)) {\n          if (!isObject(type.request)) throw new Error(`Action type.request is expected to be a Object. The value provided was: [${type.request}]`);\n          if (!isObject(type.done)) throw new Error(`Action type.request is expected to be a Object. The value provided was: [${type.done}]`);\n          if (!isObject(type.fail)) throw new Error(`Action type.request is expected to be a Object. The value provided was: [${type.fail}]`);\n        } else {\n          throw new Error('Action type was expected to be an Object.');\n        }\n\n        // We are in presence of a async action, therefore validate it has a\n        // api call.\n        if (typeof callAPI !== 'function') {\n          throw new Error('Expected fetch to be a function.');\n        }\n\n        if (!shouldCallAPI(getState())) {\n          return;\n        }\n\n        dispatch({ payload: payload, type: type.request });\n\n        // Always return a 'resolved' promise. This means that we don't need\n        // to use .catch or .then(null, errorHandler) when consuming the result\n        // of the dispatch. This also means that now everytime you attach to\n        // .then when calling .dispatch() you need to check if the result was\n        // an expected negative flow or a positive flow, you can eaily do that\n        // by checking on the params .then((result) => result.error) f.i.\n        return callAPI(apiClient).then(\n          (result) => CustomPromise.resolve(dispatch({ payload: payload, apiResponse: result.apiResponse, type: type.done })),\n          (result) => CustomPromise.resolve(dispatch({ payload: payload, apiResponse: result.apiResponse, apiError: result.apiError, type: type.fail }))\n        );\n      };\n    };\n  };\n}\n"]}