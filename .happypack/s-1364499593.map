{"version":3,"sources":["app/utils/custom_promise.js"],"names":["CustomPromise","Promise","isDev"],"mappings":";;;;;;;AAAA;;;;;;AAEA,IAAIA,gBAAgBC,OAApB;;AAGA;AACA;AACA;AACA,IAAI,cAAIC,KAAR,EAAe;AACb,UAIAF,aAJA,mBAAgBC,OAAhB;AACD;;QAGCD,a,GAAAA,a;;AAGF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gCAdIA,a","file":"custom_promise.js","sourceRoot":"/Users/damian.taborda/ws/whiteprompt/reddit/DamianTaborda_WebCodeChallenge","sourcesContent":["import env from 'utils/env';\n\nlet CustomPromise = Promise;\n\n\n// On dev use chrome native promises, opposite to Babel sandboxed version.\n// Chrome native promise impl is the same as babel one spec-wise BUT\n// gets proper stack traces on uncaught exceptions.\nif (env.isDev) {\n  CustomPromise = Promise;\n}\n\nexport {\n  CustomPromise\n};\n\n/**\n* Wrap our implentation choise of promise library so we can easily modify or fix\n* errors and also switch to a new one in case we need to. HOWEVER please be\n* careful about changes here.\n* Whenever we change promises details we need to make sure a few conditions\n* are met:\n*\n*  - Exceptions NEVER go silent. This could happen for instance if we reject a\n*    promise intentionally and there is a consumer of that promise that adds\n*    a .catch or .then(null, errorHanlder) that DOES NOT re-throws the uncaught\n*    exception, in which case we are never gonna see an error in the console for\n*    things like typo.\n*    Example:\n*\n*      apiCall().then(\n*        () => Promise.resolve('success'),\n*        () => Promise.reject('expected negative flow')\n*      ).catch(() => 'expected negative flow handling')\n*\n*    This case looks all good BUT what happens if we have a TYPO or an uncaught\n*    error inside the apiCall, in that case since we added to the outter promise\n*    a .catch the promise library is gonna think that we KNOW about the error\n*    and delegate to us the 'handling', but we are not doing anything with the\n*    exception that is gonna come in the arguments. Neither we want to do something\n*    would be massive boilerplate to do so.\n*    A solution to this is NEVER use rejected promises to state 'expected flows'.\n*\n*  - Uncaught errors: An uncaught error is basically any runtime error (typo f.i),\n*    they usually happen inside a resolveHandler or errorHandler, the problem is that\n*    some libraries do not show an error on uncaught exceptions (mostly those that have\n*    .done as part of their API). Therefore if you have something like\n*\n*      apiCall().then(() => 'do something', null);\n*\n*    and there is a typo inside the api call or even inside the 'success handler'\n*    we could get an exception that depending on the library goes unseen or gets\n*    rethrown as 'uncaught exception'.\n*\n*  - Stack traces - Uncaught exceptions.\n*    Most of the libraries that re-throw an uncaught exception will NOT provide\n*    a stacktrace that chrome would understand correctly therefore we don't get\n*    a nice stack trace. We found out that to get nice stacktraces you need to\n*    rethrow the ex in the next tick (setTimeout(() => throw error))) or use\n*    .done in the libraries that provide this, which internally does the setTimeout\n*    solution.\n*    However! the chrome native impl actually DOES throws the exception properly\n*    and you get proper stack traces, so this is always an option at least for\n*    development.\n*/\n"]}